#==============================================================================
# Title				: Wirtschaftsinformatik Labor
# Author 			: Thomas Schmidt
# Contact 			: thomas.schmidt.2@stud.hs-emden-leer.de
# Date				: 18.04.2025
# Version			: 1.0
#==============================================================================

# Import libaries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


class DBSCANVisualizer:
    """"
        # Visualizer for cluster generated by DBSCAN

        This class visualized the result from the DBSCAN Clustering algorithm.

        ## Attribute(s):
        - none

        ## Method(s):
        - 'show_animation()': shows an animation of created clusters
       

        ## Dependencies:
        - pandas
        - matplotlip
    """

    def __init__(self):
        """""
        ## Constuctor of DBSCANVisualizer class

        The constuctor takes on the root handler for the graphical user interface
        in order to display an error message box in case of an error in handling
        the csv file.

            # Parameter(s):
            - none

            # Return:
            - none
        """

    def show_animation(xy, cluster, sci_cluster, num_clusters, elapsed_time, sci_elapsed_time, sci_num_clusters):
        """
        ## This function will animate the result out of the DBSCAN

        This function will serve as an animation.

        # Parameter(s):
        - xy: Data points as a dictionary with 'x' and 'y' keys
        - cluster: Cluster cluster for the data points

        # Return:
        - none
        """
        # create a windwow for two plots
        fig, (ax4, ax1, ax2, ax3) = plt.subplots(1, 4, figsize=(18, 6))

        # put text string into a box
        textstr = f'Elapsed Time custom: {elapsed_time:.4f} seconds\nNumber of Clusters custom: {num_clusters}\nElapsed Time sci: {sci_elapsed_time:.4f} seconds\n Number of Clusters sci: {sci_num_clusters}'
        props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
        ax4.text(0.5, 0.5, textstr, transform=ax4.transAxes, fontsize=14,
                    verticalalignment='center', horizontalalignment='center', bbox=props)
        # do not show axis
        ax4.axis('off')


        # create plot for original data
        ax1.plot(xy['x'], xy['y'], 'k+', markersize=10)
        ax1.set_title('Original Data')
        #ax1.legend([textstr], loc='upper left', fontsize=12, frameon=True, fancybox=True, framealpha=0.5)

        # create second plot with data from DBSCAN custom algorithm
        unique_cluster = set(cluster)
        colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_cluster))]
        # iterate through clusters and form a tuple with (clusterid, color)
        # col is an array containing the color, coded in RGB [R, G, B, Opacity]
        for k, col in zip(unique_cluster, colors):
            # handle noise data points
            if k == -1:
                continue    # hide noise points. If they should be display, comment out this line!
                # create a RGB array for black [R, G, B, Opacity]
                black = [0, 0, 0, 1]
                # create a mask for all data points which are noise
                # True would mean, data point is noise
                class_member_mask = (cluster == k)
                # array with noise data. This array contains only the data points which where masked 
                # as noise.
                xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
                ax2.plot(xy_class[:, 0], xy_class[:, 1], '*', markerfacecolor=tuple(black), markersize=10)
            else:
                class_member_mask = (cluster == k)
                xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
                ax2.plot(xy_class[:, 0], xy_class[:, 1], 'o', markerfacecolor=tuple(col), markersize=6)
            ax2.set_title('DBSCAN Clusters Custom')
            plt.pause(.5)

        # create third plot with data from DBSCAN sci-kit algorithm
        unique_cluster_sci = set(sci_cluster)
        #colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_cluster_sci))]
        # iterate through clusters and form a tuple with (clusterid, color)
        # col is an array containing the color, coded in RGB [R, G, B, Opacity]
        for k, col in zip(unique_cluster_sci, colors):
            # handle noise data points
            if k == -1:
                continue    # hide noise points. If they should be display, comment out this line!
                # create a RGB array for black [R, G, B, Opacity]
                black = [0, 0, 0, 1]
                # create a mask for all data points which are noise
                # True would mean, data point is noise
                class_member_mask = (cluster == k)
                # array with noise data. This array contains only the data points which where masked 
                # as noise.
                xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
                ax3.plot(xy_class[:, 0], xy_class[:, 1], '*', markerfacecolor=tuple(black), markersize=10)
            else:
                class_member_mask = (sci_cluster == k)
                xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
                ax3.plot(xy_class[:, 0], xy_class[:, 1], 'o', markerfacecolor=tuple(col), markersize=6)
            ax3.set_title('DBSCAN Clusters sci-kit')
            plt.pause(.5)
        plt.show()

    def show_single_animation(self, p_data, p_cluster, p_keys):
        """
        ## This function will animate the result out of the DBSCAN

        This function will serve as an animation.

        # Parameter(s):
        - p_data (numpy array): Data points as a dictionary with 'x' and 'y' keys
        - p_cluster (numpy array): Cluster cluster for the data points
        - p_keys (list): keys for the data points

        # Return:
        - none
        """
        # create a windwow for two plots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 6))

        # create plot for original data
        ax1.plot(p_data[:, 0], p_data[:, 1], 'k+', markersize=10)  # Accessing x and y from columns 0 and 1
        ax1.set_title("Original Data")
        ax1.set_xlabel(p_keys[0])
        ax1.set_ylabel(p_keys[1])
    
        # create plot for clustered data (example)
        ax2.scatter(p_data[:, 0], p_data[:, 1], c=p_cluster, cmap='viridis')
        ax2.set_title("Clustered Data")
        ax2.set_xlabel(p_keys[0])
        ax2.set_ylabel(p_keys[1])
        plt.show()

    def show_comparison(self, p_data_1, p_cluster_1, p_data_2, p_cluster_2, p_keys1, p_keys2):
        """
        ## This function will animate the result out of the DBSCAN

        This function will serve as an animation.

        # Parameter(s):
        - p_data (numpy array): Data points as a dictionary with 'x' and 'y' keys
        - p_cluster (numpy array): Cluster cluster for the data points
        - p_keys1 (list): keys for the data points for first cluster
        - p_keys2 (list): keys for the data points for second cluster

        # Return:
        - none
        """
        # create a windwow for two plots
        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))

        # create plot for original data
        ax1.plot(p_data_1[:, 0], p_data_1[:, 1], 'k+', markersize=10)  # Accessing x and y from columns 0 and 1
        ax1.set_title("Original Data")
        ax1.set_xlabel(p_keys1[0])
        ax1.set_ylabel(p_keys1[1])

        # create plot for clustered data set 1
        ax2.scatter(p_data_1[:, 0], p_data_1[:, 1], c=p_cluster_1, cmap='viridis')
        ax2.set_title("Data Set 1")
        ax2.set_xlabel(p_keys1[0])
        ax2.set_ylabel(p_keys1[1])

        # create plot for clustered data set 2
        ax3.scatter(p_data_2[:, 0], p_data_2[:, 1], c=p_cluster_2, cmap='viridis')
        ax3.set_title("Data Set 2")
        ax3.set_xlabel(p_keys2[0])
        ax3.set_ylabel(p_keys2[1])
        plt.show()
