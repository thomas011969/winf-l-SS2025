#==============================================================================
# Title				: Wirtschaftsinformatik Labor
# Author 			: Thomas Schmidt
# Contact 			: thomas.schmidt.2@stud.hs-emden-leer.de
# Date				: 18.04.2025
# Version			: 1.0
#==============================================================================

# Import libaries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time

class DBSCANVisualizer:
     """"
        # Visualizer for cluster generated by DBSCAN

        This class visualized the result from the DBSCAN Clustering algorithm.

        ## Attribute(s):
        - none

        ## Method(s):
        - 'plot_sales()': returns a data frame of a timeline of sales per month
       

        ## Dependencies:
        - pandas
        - matplotlip
    """

    def __init__(self):
        """""
        ## Constuctor of DBSCANVisualizer class

        The constuctor takes on the root handler for the graphical user interface
        in order to display an error message box in case of an error in handling
        the csv file.

        # Parameter(s):
        - 'p_root' (tkinter root handle): handle for the graphical user interface

        # Return:
        - none
        """

def show_animation(xy, cluster, sci_cluster, num_clusters, elapsed_time, sci_elapsed_time, sci_num_clusters):
    """
    ## This function will animate the result out of the DBSCAN

    This function will serve as an animation.

    # Parameter(s):
    - xy: Data points as a dictionary with 'x' and 'y' keys
    - cluster: Cluster cluster for the data points

    # Return:
    - none
    """
    # create a windwow for two plots
    fig, (ax4, ax1, ax2, ax3) = plt.subplots(1, 4, figsize=(18, 6))

    # put text string into a box
    textstr = f'Elapsed Time custom: {elapsed_time:.4f} seconds\nNumber of Clusters custom: {num_clusters}\nElapsed Time sci: {sci_elapsed_time:.4f} seconds\n Number of Clusters sci: {sci_num_clusters}'
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
    ax4.text(0.5, 0.5, textstr, transform=ax4.transAxes, fontsize=14,
                verticalalignment='center', horizontalalignment='center', bbox=props)
    # Achsen ausblenden
    ax4.axis('off')


    # create plot for original data
    ax1.plot(xy['x'], xy['y'], 'k+', markersize=10)
    ax1.set_title('Original Data')
    #ax1.legend([textstr], loc='upper left', fontsize=12, frameon=True, fancybox=True, framealpha=0.5)

    # create second plot with data from DBSCAN custom algorithm
    unique_cluster = set(cluster)
    colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_cluster))]
    # iterate through clusters and form a tuple with (clusterid, color)
    # col is an array containing the color, coded in RGB [R, G, B, Opacity]
    for k, col in zip(unique_cluster, colors):
        # handle noise data points
        if k == -1:
            continue    # hide noise points. If they should be display, comment out this line!
            # create a RGB array for black [R, G, B, Opacity]
            black = [0, 0, 0, 1]
            # create a mask for all data points which are noise
            # True would mean, data point is noise
            class_member_mask = (cluster == k)
            # array with noise data. This array contains only the data points which where masked 
            # as noise.
            xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
            ax2.plot(xy_class[:, 0], xy_class[:, 1], '*', markerfacecolor=tuple(black), markersize=10)
        else:
            class_member_mask = (cluster == k)
            xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
            ax2.plot(xy_class[:, 0], xy_class[:, 1], 'o', markerfacecolor=tuple(col), markersize=6)
        ax2.set_title('DBSCAN Clusters Custom')
        plt.pause(.5)

    # create third plot with data from DBSCAN sci-kit algorithm
    unique_cluster_sci = set(sci_cluster)
    #colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_cluster_sci))]
    # iterate through clusters and form a tuple with (clusterid, color)
    # col is an array containing the color, coded in RGB [R, G, B, Opacity]
    for k, col in zip(unique_cluster_sci, colors):
        # handle noise data points
        if k == -1:
            continue    # hide noise points. If they should be display, comment out this line!
            # create a RGB array for black [R, G, B, Opacity]
            black = [0, 0, 0, 1]
            # create a mask for all data points which are noise
            # True would mean, data point is noise
            class_member_mask = (cluster == k)
            # array with noise data. This array contains only the data points which where masked 
            # as noise.
            xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
            ax3.plot(xy_class[:, 0], xy_class[:, 1], '*', markerfacecolor=tuple(black), markersize=10)
        else:
            class_member_mask = (sci_cluster == k)
            xy_class = np.array([xy['x'][class_member_mask], xy['y'][class_member_mask]]).T
            ax3.plot(xy_class[:, 0], xy_class[:, 1], 'o', markerfacecolor=tuple(col), markersize=6)
        ax3.set_title('DBSCAN Clusters sci-kit')
        plt.pause(.5)
    plt.show()

